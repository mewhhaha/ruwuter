import path from "node:path";
import { mkdir, readdir, rm, writeFile } from "node:fs/promises";
import { Dirent } from "fs";

const CLIENT_FILE_PATTERN = /\.client\.(?:[cm]?ts|tsx|[cm]?js)$/i;
const IGNORED_DIRS = new Set([
    "node_modules",
    ".git",
    ".router",
    "dist",
    "build",
]);
const DECLARATION_SUFFIX = "?url&no-inline.d.ts";

type DirEntry = {
    name: string;
    path: string;
    isDirectory: boolean;
};

const readEntries = async (dir: string): Promise<DirEntry[]> => {
    const items = await readdir(dir, { withFileTypes: true });
    return items
        .filter((entry) => !IGNORED_DIRS.has(entry.name))
        .map((entry) => ({
            name: entry.name,
            path: path.join(dir, entry.name),
            isDirectory: entry.isDirectory(),
        }));
};

const walk = async (root: string): Promise<string[]> => {
    const stack: DirEntry[] = [{ name: "", path: root, isDirectory: true }];
    const files: string[] = [];

    while (stack.length) {
        const current = stack.pop()!;
        if (!current.isDirectory) continue;
        const entries = await readEntries(current.path);
        for (const entry of entries) {
            if (entry.isDirectory) {
                stack.push(entry);
                continue;
            }
            files.push(entry.path);
        }
    }

    return files;
};

const ensureOutputDir = async (outputFile: string): Promise<void> => {
    const dir = path.dirname(outputFile);
    await mkdir(dir, { recursive: true });
};

const gatherDeclarationFiles = async (root: string): Promise<string[]> => {
    const stack: string[] = [root];
    const files: string[] = [];

    while (stack.length) {
        const current = stack.pop()!;
        let entries: Dirent<string>[];
        try {
            entries = await readdir(current, { withFileTypes: true });
        } catch {
            continue;
        }

        for (const entry of entries) {
            const entryPath = path.join(current, entry.name);
            if (entry.isDirectory()) {
                stack.push(entryPath);
                continue;
            }
            if (!entry.name.endsWith(DECLARATION_SUFFIX)) continue;
            files.push(entryPath);
        }
    }

    return files;
};

const createDeclarationContent = (handlerFileName: string): string => {
    return [
        "// Auto-generated by generateClientHandlerTypes. Do not edit manually.",
        "",
        'import type { HandlerModule, HandlerAssert } from "@mewhhaha/ruwuter/events";',
        `import type * as Mod from "./${handlerFileName}";`,
        "",
        "type Fn = HandlerAssert<typeof Mod.default>;",
        "declare const href: HandlerModule<Fn>;",
        "export default href;",
        "",
    ].join("\n");
};

const removeStaleDeclarations = async (
    root: string,
    keep: Set<string>,
): Promise<void> => {
    const existing = await gatherDeclarationFiles(root);
    await Promise.all(
        existing
            .filter((file) => !keep.has(path.resolve(file)))
            .map((file) => rm(file, { force: true })),
    );
};

export const generateClientHandlerTypes = async (
    appFolder: string,
): Promise<void> => {
    const resolvedAppFolder = path.resolve(appFolder);
    const relativeAppFolder =
        path.relative(process.cwd(), resolvedAppFolder) ||
        path.basename(resolvedAppFolder);
    const typeRoot = path.join(".router", "types");
    const typeAppRoot = path.join(typeRoot, relativeAppFolder);

    let handlerFiles: string[] = [];
    try {
        const allFiles = await walk(resolvedAppFolder);
        handlerFiles = allFiles.filter((file) =>
            CLIENT_FILE_PATTERN.test(file),
        );
    } catch {
        await removeStaleDeclarations(typeAppRoot, new Set());
        return;
    }

    if (handlerFiles.length === 0) {
        await removeStaleDeclarations(typeAppRoot, new Set());
        return;
    }

    const expected = new Set<string>();

    for (const handlerAbs of handlerFiles) {
        const relativeHandler = path.relative(resolvedAppFolder, handlerAbs);
        const outputFile = path.join(
            typeAppRoot,
            `${relativeHandler}${DECLARATION_SUFFIX}`,
        );
        expected.add(path.resolve(outputFile));

        await ensureOutputDir(outputFile);
        const content = createDeclarationContent(path.basename(handlerAbs));
        await writeFile(outputFile, content);
    }

    await removeStaleDeclarations(typeAppRoot, expected);
};
