import { mkdir, readdir, rm, writeFile } from "node:fs/promises";
import path from "node:path";

const CLIENT_FILE_PATTERN = /\.client\.(?:[cm]?ts|tsx|[cm]?js)$/i;
const SOURCE_FILE_PATTERN = /\.(?:[cm]?ts|tsx|jsx|[cm]?js)$/i;
const IGNORED_DIRS = new Set(["node_modules", ".git", ".router", "dist", "build"]);

type DirEntry = {
  name: string;
  path: string;
  isDirectory: boolean;
};

const toPosix = (value: string): string => value.replaceAll(path.sep, "/");

const readEntries = async (dir: string): Promise<DirEntry[]> => {
  const items = await readdir(dir, { withFileTypes: true });
  return items
    .filter((entry) => !IGNORED_DIRS.has(entry.name))
    .map((entry) => ({
      name: entry.name,
      path: path.join(dir, entry.name),
      isDirectory: entry.isDirectory(),
    }));
};

const walk = async (root: string): Promise<string[]> => {
  const stack: DirEntry[] = [{ name: "", path: root, isDirectory: true }];
  const files: string[] = [];

  while (stack.length) {
    const current = stack.pop()!;
    if (!current.isDirectory) continue;
    const entries = await readEntries(current.path);
    for (const entry of entries) {
      if (entry.isDirectory) {
        stack.push(entry);
        continue;
      }
      files.push(entry.path);
    }
  }

  return files;
};

const ensureOutputDir = async (outputFile: string): Promise<void> => {
  const dir = path.dirname(outputFile);
  await mkdir(dir, { recursive: true });
};

const relativeImportPath = (from: string, to: string): string => {
  const rel = toPosix(path.relative(from, to));
  return rel.startsWith(".") ? rel : `./${rel}`;
};

const makeModuleBlock = (
  moduleSpecifier: string,
  importPath: string,
): string => {
  return [
    `declare module ${moduleSpecifier} {`,
    `  import type { HandlerModule, HandlerAssert } from "@mewhhaha/ruwuter/events";`,
    `  type Fn = HandlerAssert<typeof import("${importPath}")["default"]>;`,
    `  const href: HandlerModule<Fn>;`,
    `  export default href;`,
    `}`,
  ].join("\n");
};

export const generateClientHandlerTypes = async (appFolder: string): Promise<void> => {
  const normalizedApp = path.resolve(appFolder);
  const files = await walk(normalizedApp);

  const handlerFiles = files.filter((file) => CLIENT_FILE_PATTERN.test(file));
  if (handlerFiles.length === 0) {
    await rm(path.join(".router", "types", appFolder, "+client-handlers.d.ts"), {
      force: true,
    });
    return;
  }

  const sourceFiles = files.filter((file) => SOURCE_FILE_PATTERN.test(file));
  if (sourceFiles.length === 0) {
    // No importers discovered; still emit declarations referencing handlers themselves
    sourceFiles.push(path.join(normalizedApp, "index.ts"));
  }

  const outputFile = path.join(".router", "types", appFolder, "+client-handlers.d.ts");
  await ensureOutputDir(outputFile);
  const outputDir = path.dirname(path.resolve(outputFile));

  const blocks: string[] = [];
  const seen = new Set<string>();

  for (const handlerAbs of handlerFiles) {
    const handlerImportPath = relativeImportPath(outputDir, handlerAbs);

    for (const importer of sourceFiles) {
      const importerDir = path.dirname(importer);
      const relativeToImporter = relativeImportPath(importerDir, handlerAbs);
      const baseSpec = toPosix(relativeToImporter);

      const explicit = `${baseSpec}?url`;
      if (!seen.has(explicit)) {
        blocks.push(makeModuleBlock(JSON.stringify(explicit), handlerImportPath));
        seen.add(explicit);
      }

      const suffixSpec = `\`${baseSpec}?url\${string}\``;
      if (!seen.has(suffixSpec)) {
        blocks.push(makeModuleBlock(suffixSpec, handlerImportPath));
        seen.add(suffixSpec);
      }

      const reorderedSpec = `\`${baseSpec}?\${string}&url\${string}\``;
      if (!seen.has(reorderedSpec)) {
        blocks.push(makeModuleBlock(reorderedSpec, handlerImportPath));
        seen.add(reorderedSpec);
      }
    }
  }

  const banner = `// Auto-generated by generateClientHandlerTypes. Do not edit manually.`;
  const body = blocks.join("\n\n");
  await writeFile(outputFile, `${banner}\n\n${body}\n`);
};
